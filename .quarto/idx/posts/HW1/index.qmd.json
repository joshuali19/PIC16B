{"title":"SQL Queries and Plotly Visualizations","markdown":{"yaml":{"title":"SQL Queries and Plotly Visualizations","author":"Joshua Li","date":"2023-02-01","categories":["code","analysis"],"jupyter":"pic16b"},"headingText":"Create a Database","headingAttr":{"id":"step1","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\nIn this blog post, we will be diving deeper into data visualization, specifically with plotly. By the end of this post, you will be able to:\n\n1. [Create a database that stores tables](#step1)\n2. [Utilize SQL to extract necessary data](#step2)\n3. [Create a data visualization using plotly](#step3)\n\nThis article is a good exercise for the data visualization process. I will first go through the steps, and then provide additional examples.\n\n\nFirst, we need to create a database that will store all the necessary data we need in order to create our visualizations. This is done through the `sqlite3` library. The `.csv` files were downloaded as toy datasets from a class curriculum.\n\n```{python}\nimport sqlite3\nimport pandas as pd\n\n# initialize a connection to new database\nconn = sqlite3.connect(\"weather.db\")\n\ndef create_table(df, out_name, **kwargs):\n    '''\n    Input:\n    - df (str): path of the data frame\n    - out_name (str): name of output table\n    - **kwargs: keyword arguments for to_sql\n    '''\n    tbl = pd.read_csv(df) # reads csv\n    tbl.to_sql(out_name, **kwargs) # transfers csv to sql database\n\n# repetitive keywords\nkeywords = {'con': conn, 'index': False, 'if_exists': 'replace'}\n\n# create 3 tables\ncreate_table(\"temps_stacked.csv\", \"temperatures\", **keywords)\ncreate_table(\"countries.csv\", \"countries\", **keywords)\ncreate_table(\"station-metadata.csv\", \"stations\", **keywords)\n\n# verify that 3 tables are in the database\ncursor = conn.cursor()\ncursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\nprint(cursor.fetchall())\nconn.close() # close connection\n```\n\nAfter this code is run, we have a database labelled `weather.db`, containing 3 tables `temperatures`, `countries`, and `stations`. Here is a brief description of each table:\n\n- `temperatures`: a list of temperature recordings of stations every month and year.\n- `countries`: country names, their respective IDs, and abbreviations\n- `stations`: station names, what country they are in, as well as latitude and longitude.\n\n## Extract the Necessary Data {#step2}\n\nNow, we need to achieve the necessary data and compile it into a file that we will use for the visualization. Each of the three tables contain important information and relationships that would be helpful if they were all merged together. We will write a function that takes a `SQL` query to take these tables, extract the necessary columns from each, and output a dataframe with all the information to create a visualization. I would encourage you to look at each of the tables and their columns to get a sense of what information there is. For the sake of this demonstration, this will be given to you. We want\n\n- The station name\n- The latitude of the station\n- The longitude of the station\n- The country where the station is located in\n- The year the reading was taken\n- The month the reading was taken\n- The average temperature at this station at the given year and month\n\n### Construct a SQL Query\n\nThis function we are able to make will only work if we extract the right information from the `SQL` query. This subsection will inform you of the `SQL` syntax, and some common tips.\n\n#### 1. SQL Syntax\n\nThere are various keywords used in `SQL` that form a query. Here is a brief overview of the commands necessary for reading a table.\n\n- `SELECT` - extracts columns from table\n- `FROM` - used in conjunction with `SELECT` to specifies the table you are extracting from\n- `(FULL|INNER|RIGHT|LEFT) JOIN` - joins two tables together (the four keywords denote if a table keeps all their data)\n- `ON` - used in conjunction with `JOIN` keyword to specify the columns that link the two tables together\n- `WHERE` - subsets the table to a given specification\n- `GROUP BY` - similar to `pandas.groupby()`, groups table by specific columns\n- `HAVING` - used in conjunction with `GROUP BY` to specify more subsetting within groups.\n- `ORDER BY` - rearranges table to order by specific columns\n- `DESC` - used in conjunction with `ORDER BY` to specify reverse ordering\n- `LIMIT` - limits the number of rows outputted\n\n#### 2. Common Tips\n\nThere are a couple queries that are commonly used in `SQL`. Here are some of them, and I will explain it all in detail\n\n##### Example 1:\n```sql\nSELECT * FROM temperatures;\n```\n\nThe * character denotes a wildcard, meaning all columns. This statement will extract all columns from the temperatures table.\n\n##### Example 2:\n```sql\nSELECT year, month, temperature FROM temperatures\nWHERE month = 12;\n```\n\nGet the year, month, and temperature from the temperatures table, subsetted only to the month of December.\n\n##### Example 3:\n```sql\nSELECT t.id, t.temperature, s.name FROM temperatures t\nINNER JOIN stations s\nON s.id = t.id;\n```\n\nGet the id and temperature from temperatures and name from stations, aliased as t and s, respectively.\n\n##### Example 4:\n```sql\nSELECT t.id, t.temperature, s.name FROM temperatures t\nINNER JOIN stations s\nON s.id = t.id\nWHERE t.temperature > 20;\n```\n\nThe same query as Example 3, but subsetted by temperatures greater than 20.\n\n##### Example 5:\n```sql\nSELECT t.id, AVG(t.temperature), t.year, s.name FROM temperatures t\nINNER JOIN stations s\nON s.id = t.id\nGROUP BY t.year;\n```\n\nThe same query as Example 3, but now calculating the average temperature grouped by year.\n\n#### 3. Constructing the Query\n\nNow that we have a better understanding of `SQL`, we will have to construct the query that will serve as the basis for this function. Here are the specs for the query, for your convenience:\n\n- The station name\n- The latitude of the station\n- The longitude of the station\n- The country where the station is located in\n- The year the reading was taken\n- The month the reading was taken\n- The average temperature at this station at the given year and month\nWe can start by writing down the columns in a `SQL` format. However, these variables are not all found in the same table, so we need to join tables together in order for the initial query to work. Look into the tables in your own time to see that the relation key between the `temperatures` and `stations` tables is by their ID, and the relationship between `temperatures` and `countries` is by a subset of the ID corresponding with the countryâ€™s FIPS 10-4 code'.\n\n```sql\nSELECT s.Name, s.latitude, s.longitude, c.Name, t.year, t.month, t.temperature\nFROM temperatures t\nLEFT JOIN stations s ON t.id = s.id\nLEFT JOIN countries c ON SUBSTRING(t.id, 1, 2) = c.[FIPS 10-4]\n```\n\nHowever, one of the things that we want to do is to specify subsetting by country, year and month. We can do this by adding the `WHERE` clause.\n\n```sql\nSELECT s.Name, s.latitude, s.longitude, c.Name, t.year, t.month, t.temperature\nFROM temperatures t\nLEFT JOIN stations s ON t.id = s.id\nLEFT JOIN countries c ON SUBSTRING(t.id, 1, 2) = c.[FIPS 10-4]\nWHERE c.NAME == \"<country name>\"\nAND t.year < <year_end>\nAND t.year > <year_begin>\nAND t.month == <month>\n```\n\nThis is the framework of the query we will use for the function.\n\n### Constructing the Function\n\n```{python}\nimport sqlite3\nimport pandas as pd\nimport numpy as np\n\nconn = sqlite3.connect('weather.db')\ndef query_climate_database(country, year_begin, year_end, month):\n    '''\n    runs a SQL query that obtains temperature data for stations in a certain country for given years and months.\n    @input:\n    - country (str): (Official) Country Name \n    - year_begin (int): starting year to look for\n    - year_end (int): end year to look for\n    - month (int): which month to look at\n    @output:\n    - df: takes SQL results as a dataframe\n    '''\n\n    # SQL query\n    cmd = '''\n    SELECT s.Name, s.latitude, s.longitude, c.Name, t.year, t.month, t.temp\n    FROM temperatures t\n    LEFT JOIN stations s ON t.id = s.id\n    LEFT JOIN countries c ON SUBSTRING(t.id, 1, 2) = c.[FIPS 10-4]\n    WHERE c.NAME == \\\"{0}\\\"\n    AND t.year <= {2} AND t.year >= {1}\n    AND t.month == {3}'''.format(country, year_begin, year_end, month)\n\n    # establish connection\n    \n    return pd.read_sql_query(cmd, conn) # return data frame\n\nquery_climate_database(\"India\", 1980, 2020, 1)\n```\n\n## Creating a Data Visualization {#step3}\n\n```{python}\nimport plotly.express as px\nfrom sklearn.linear_model import LinearRegression\n\ndef LR_group_coef(df, x_cols, y_col):\n    '''\n    takes a data frame, runs a linear regression, finds the slope coefficient for the first column in x_cols\n    @ input:\n    - df (df): data frame to perform linear regression on\n    - x_cols (list): list of string column names\n    - y_col (str): response column name\n    @ output:\n    - first slope coefficient\n    '''\n    return LinearRegression().fit(df[x_cols], df[[y_col]]).coef_[0][0]\n\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):\n    '''\n    plots an interactive geoscatter plot (plotly) with stations as points, with color denoting inferred yearly increase in temperature at that station for that given time period (years) and month.\n    @input:\n    - country (str): (official country name)\n    - year_begin (int): when time period starts\n    - year_end (int): when time period ends\n    - month (int): which month to subset\n    - min_obs (int): minimum number of observations a station must have for this data to run\n    - **kwargs: keyword arguments for plotting\n    @output:\n    - figure: see description\n    '''\n    # get the necessary data\n    df1 = query_climate_database(country, year_begin, year_end, month)\n\n    # drop the stations that have less than n_obs values\n    df2 = df1.copy()\n    df2['n_obs'] = df2.groupby('NAME')['Month'].transform(len)\n    df2['valid'] = df2['n_obs'] >= min_obs\n    df = df2[df2['valid'] == True]\n    df = df.drop(columns = [\"n_obs\", \"valid\"])\n\n    # prep for regression\n    X = df.drop(columns = ['Temp'])\n    y = df[['Temp']]\n\n    # find the average change in temp for each station\n    model_coef = df.groupby('NAME').apply(LR_group_coef,\n    x_cols = ['Year', 'Month'], y_col = 'Temp')\n\n    # map it to the respective stations\n    df['Average Temp Increase'] = np.round(df['NAME'].map(dict(model_coef)), 3)\n\n    # recode months\n    month_recode = {1: 'January',\n    2: 'February',\n    3: 'March',\n    4: 'April',\n    5: 'May',\n    6: 'June',\n    7: 'July',\n    8: 'August',\n    9: 'September',\n    10: 'October',\n    11: 'November',\n    12: 'December'}\n\n    # make the geoscatter plot\n    title = \"Estimates of yearly increase in temperature in {0}<br>for stations in {1}, years {2}-{3}\".format(month_recode[month], country, year_begin, year_end)\n    fig = px.scatter_mapbox(df, lat = 'LATITUDE', lon = 'LONGITUDE',\n    color = 'Average Temp Increase', hover_name = 'NAME', color_continuous_midpoint = 0, title = title, **kwargs)\n\n    fig.show(renderer = \"notebook\")\n    # return df\n\ncolor_map = px.colors.diverging.RdBu_r\n\ntemperature_coefficient_plot(\"India\", 1980, 2020, 1, 10,\n                                    zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n```\n\nHere is another plot for China in the same time period for January.\n\n```{python}\ntemperature_coefficient_plot(\"China\", 1980, 2020, 1, 10,\nzoom = 2,\nmapbox_style = 'carto-positron',\ncolor_continuous_scale = color_map)\n```\n\n## Additional Examples\n\n```{python}\ndef monthly_temp(country, year_begin, year_end):\n    '''\n    runs a SQL query that obtains temperature data for a station in a certain country for given years.\n    @input:\n    - country (str): (official country name)\n    - year_begin (int): starting year to look for\n    - year_end (int): end year to look for\n    @output:\n    - df: takes SQL results as a dataframe\n    '''\n\n    # SQL query\n    cmd = '''\n    SELECT s.Name, s.latitude, s.longitude, c.Name, t.year, t.month, t.temp\n    FROM temperatures t\n    LEFT JOIN stations s ON t.id = s.id\n    LEFT JOIN countries c ON SUBSTRING(t.id, 1, 2) = c.[FIPS 10-4]\n    WHERE c.Name == \\\"{0}\\\"\n    AND t.year <= {2} AND t.year >= {1}'''.format(country, year_begin, year_end)\n\n    # establish connection\n    return pd.read_sql_query(cmd, conn) # return data frame\n\ndef median_monthly_temp(country, year_begin, year_end, **kwargs):\n    '''\n    shows the distribution of temperature by month for a station\n    @ input:\n    - country (str): (official country name)\n    - year_begin (int): starting year to look for\n    - year_end (int): end year to look for\n    - **kwargs: keyword arguments for px.box\n    @ output:\n    fig: displays the boxplot\n    '''\n\n    # get necessary data\n    df = monthly_temp(country, 1980, 2020)\n\n    # recode month\n    month_recode = {1: 'January',\n    2: 'February',\n    3: 'March',\n    4: 'April',\n    5: 'May',\n    6: 'June',\n    7: 'July',\n    8: 'August',\n    9: 'September',\n    10: 'October',\n    11: 'November',\n    12: 'December'}\n    df['Month'] = df['Month'].map(month_recode)\n\n    # plot the box plot\n    title = 'Distribution of Temperature by Month,<br>{0} {1}-{2}'.format(country, year_begin, year_end)\n    fig = px.box(df, x=\"Month\", y=\"Temp\", title = title, **kwargs)\n    fig.show(renderer = \"notebook\")\n\nmedian_monthly_temp('India', 1980, 2020)\n```\n\nWith this query, we extracted all the necessary information to show a distribution of temperature by month for a given country. In the example plot, we have a distribution of mean temperatures for each month in India. This helps to answer the question: **Which month is most likely to have the highest mean temperatures for a country?** We can see that through the visualization, it gives us that information, while also showing a general distribution to compare between months easily. This utilizes the box plot to help diminish the issue of missing data.\n\n```{python}\ndef monthly_temp_time(country, year_begin, year_end, station, **kwargs):\n    '''\n    shows the trend of mean temperature by month for a station in a country\n    @ input:\n    - country (str): (official country name)\n    - year_begin (int): starting year to look for\n    - year_end (int): end year to look for\n    - station (str): station name\n    - **kwargs: keyword arguments for px.line\n    @ output:\n    fig: displays the lineplot\n    '''\n    \n    # get necessary data\n    df = monthly_temp(country, year_begin, year_end)\n\n    # sort the dataframe\n    sorted_df = df.copy()\n    # map the value order\n    sorted_df[\"order\"] = sorted_df[\"NAME\"].map({station: 1}).fillna(2)\n    \n    # recode months\n    month_recode = {1: 'January',\n    2: 'February',\n    3: 'March',\n    4: 'April',\n    5: 'May',\n    6: 'June',\n    7: 'July',\n    8: 'August',\n    9: 'September',\n    10: 'October',\n    11: 'November',\n    12: 'December'}\n    sorted_df['Month'] = sorted_df['Month'].map(month_recode)\n    # sort by this order\n    sorted_df.sort_values(by=[\"order\",\"Year\"], ascending=False, inplace=True)\n\n    # make the plot\n    title = \"Progression of Temperature in {0} by Month, {3} {1}-{2}\".format(country, year_begin, year_end, station)\n    fig = px.line(sorted_df, x = 'Year', y = 'Temp', color = 'NAME', **kwargs)\n    fig.update_traces({\"line\":{\"color\":\"lightgrey\"}}) # hide unnecessary data\n    fig.update_traces(patch={\"line\":{\"color\":\"red\", \"width\":3}}, \n                  selector={\"legendgroup\":station}) # highlight specific station\n    fig.update_layout(title=title,\n                showlegend=False,\n                margin = {'l': 0, 'r':0, 't': 50, 'b': 0},\n                width = 800,\n                ) # format\n    fig.show(renderer = \"notebook\")\n\nmonthly_temp_time('India', 1980, 2020, 'TEZPUR', facet_col = 'Month', facet_col_wrap = 4)\n```\n\n```{python}\nconn.close()\n```\n\nThis plot is created from the same query, but is now looking at trends over time. We ask the question: **What trends, if any, are there about the mean temperature by month over the years for a given station?** This utilizes a line plot to point out potential trends, and uses selective highlighting to point out a specific station with reference to other stations within the country. It also tells us about potential missing data, since not all lines start at the same point. For this particular station Tezpur, we do not see any particular trend for any given month, but that would have to be verified with numbers.\n\n## Conclusion\n\nThrough this post, we learned how to create a database, how to construct and run queries, and to create cool data visualizations on plotly. As you get more familiar with plotly, I would highly recommend you look into the [official documentation](https://plotly.com/python/) to better customize your plots to fit your needs and what you need to convey to the audience.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":"flatly","title-block-banner":true,"title":"SQL Queries and Plotly Visualizations","author":"Joshua Li","date":"2023-02-01","categories":["code","analysis"],"jupyter":"pic16b"},"extensions":{"book":{"multiFile":true}}}}}